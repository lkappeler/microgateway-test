/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-cli-logger

var bunyan = require('bunyan');
var path = require('path');
var osenv = require('osenv');
var mkdirp = require('mkdirp');
var f = require('util').format;
var extend = require('deep-extend');
var Promise = require('bluebird');
var fs = require('fs');
var inspect = require('util').inspect;

var dirName = process.env.APIC_CLI_CONFIG_DIR || '.apiconnect';
var configDir = process.env.APIC_CONFIG_PATH || path.resolve(osenv.home(), dirName);
mkdirp.sync(configDir);

// initialize logger streams
var formatter = require('./lib/formatter.js');
var rotStream = require('logrotate-stream');
var fileName = process.env.APIC_CLI_LOG_FILE || 'apic.log';
// default file logger config
var defaultFileLoggerCfg = {
  file: path.join(configDir, fileName),
  size: '50M',
  keep: 10,
  objectMode: true,
};

// default bunyan logger config
var defaultBunyanCfg = {
  name: 'API Connect',
  streams: [
    {
      level: process.env.LOG_LEVEL || process.env.APIC_LOG_CONSOLE_LEVEL || 'warn',
      stream: formatter,
    },
  ],
  src: false,
};

// Merge default configs with user provided configuration files
var config = loadConfig(defaultBunyanCfg, defaultFileLoggerCfg);
var rotateLogStream = rotStream(config.fileLoggerOpts);

// add file logger stream
config.bunyanOpts.streams.push({
  level: process.env.FILE_LOG_LEVEL || process.env.APIC_LOG_FILE_LEVEL || 'info',
  stream: rotateLogStream,
});

// Bind info and err to allow use of "apply" and "call"
var logger = bunyan.createLogger(config.bunyanOpts);
logger.info = logger.info.bind(logger);
logger.err = logger.error.bind(logger);

logger.debug('logger initialized with config:\n %s', inspect(config, { depth: 3 }));
/**
 * Write <tt>str</tt> to the stdout - no newline is printed after <tt>str</tt>
 *
 * @param str {String} printed to stdout
 */
logger.write = function() {
  process.stdout.write(f.apply(null, arguments));
  logger.info.apply(null, arguments);
};

/**
 * Write <tt>str</tt> to the stdout - newline is printed after <tt>str</tt>
 *
 * @param str {String} printed to stdout
 */
logger.writeln = function() {
  process.stdout.write(f.apply(null, arguments) + '\n');
  logger.info.apply(null, arguments);
};

// Wrap error printing to send stack trace to debug instead of stderr
var oldError = logger.error;
logger.error = function(err) {
  if (err instanceof Error) {
    oldError.call(this, err.message);
    return logger.debug(err.stack);
  }
  logger.err.apply(this, arguments);
};

// Route severe to error to preserve winston backwards compatibility
logger.severe = function() {
  logger.err.apply(null, arguments);
};

// Preserve exitcode while flushing file streams
logger.exit = function(exitCode) {
  return logger.flush('exiting with code %d', exitCode).finally(function() {
    process.exit(exitCode);
  });
};

// Handle uncaught exceptions to avoid stack trace in console
process.on('uncaughtException', function(err) {
  logger.error(err.message);
  logger.flush(err.stack).finally(function() {
    process.exit(1);
  });
});

module.exports = logger;

// Manually close 'file' configStreams before exiting
bunyan.prototype.flush = function() {
  var streams = this.streams;

  var args = Array.prototype.slice.call(arguments);
  if (args.length > 0) {
    logger.debug.apply(logger, args);
  } else {
    logger.debug('flush logs');
  }

  return new Promise(function(resolve, reject) {
    if (this._closed) { resolve(); }

    var remaining = streams.length;
    if (!remaining) { resolve(); }
    streams.forEach(function(s) {
      if (s.stream) {
        s.stream.on('finish', function() {
          if (!--remaining) { resolve(); }
        });
        // If stream can't be ended manually, then assume it will end properly
        if (s.stream.end) {
          s.stream.end();
        } else {
          remaining--;
        }
      }
    });

    this._closed = true;
  });
};

function loadConfig(bunyanCfg, fileLoggerCfg) {
  var fileOptions = {};
  // Load user specified configuration file. If it isn't specified, look in default location
  if (process.env.APIC_LOG_CONFIG_FILE) {
    console.log('Logger configured by $APIC_LOG_CONFIG_FILE: %s', process.env.APIC_LOG_CONFIG_FILE);
    var userConfigFile = path.resolve(process.env.APIC_LOG_CONFIG_FILE);
    if (fileExists(userConfigFile)) {
      // Unhandled error
      fileOptions = require(userConfigFile);
    }
  } else {
    // Load default configuration file. JSON takes priority over JS file of the same name.
    var defaultConfigFileJson = path.join(configDir, 'logger-config.json');
    var defaultConfigFileJs = path.join(configDir, 'logger-config.js');
    if (fileExists(defaultConfigFileJson)) {
      console.log('Logger configured by: %s', defaultConfigFileJson);
      // These require statements are unhandled. If the file exists but user made a mistake, for example
      // incorrect JSON or faulty require statements, user should get some feedback.
      fileOptions = require(defaultConfigFileJson);
    } else if (fileExists(defaultConfigFileJs)) {
      console.log('Logger configured by: %s', defaultConfigFileJs);
      // Unhandled error
      fileOptions = require(defaultConfigFileJs);
    }
  }
  // Merge bunyan logger configuration
  if (fileOptions.bunyan) {
    // Concat streams
    var concatStreams = bunyanCfg.streams;
    if (fileOptions.bunyan.streams) {
      concatStreams = bunyanCfg.streams.concat(fileOptions.bunyan.streams);
    }
    extend(bunyanCfg, fileOptions.bunyan);
    bunyanCfg.streams = concatStreams;
  }

  // Merge fileLogger configuration
  if (fileOptions.filelogger) {
    extend(fileLoggerCfg, fileOptions.filelogger);
  }

  return {
    bunyanOpts: bunyanCfg,
    fileLoggerOpts: fileLoggerCfg,
  };

  function fileExists(path) {
    try {
      var stats = fs.statSync(path);
      if (stats.isFile()) {
        return true;
      }
    } catch (err) {
      return false;
    }
  }
}

