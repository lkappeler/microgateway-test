/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-project

'use strict';

var Promise = require('bluebird');
var fs = require('fs');
var g = require('strong-globalize')();
var jsYaml = require('js-yaml');
var path = require('path');
var traverse = require('traverse');

function derefArtifacts(artifacts) {
  if (!Array.isArray(artifacts)) {
    artifacts = [ artifacts ];
  }
  return Promise.map(artifacts, processArtifact);
};

function processArtifact(artifact) {
  if (artifact.type === 'swagger') {
    return processSwagger(artifact);
  } else if (artifact.type === 'product') {
    return Promise.map(artifact.refs, processSwagger)
      .then(function(processed) {
        artifact.refs = processed;
        return artifact;
      });
  } else {
    return Promise.resolve(artifact);
  }
};

function processSwagger(swaggerArtifact) {
  // If there was already an error attached to this artifact, don't try to expand. It's possible that this artifact
  // doesn't exist
  if (swaggerArtifact.err) {
    return Promise.resolve(swaggerArtifact);
  }
  try {
    swaggerArtifact.data = expandExternalRefs(swaggerArtifact.data, swaggerArtifact.filePath);
  } catch (err) {
    swaggerArtifact.err = new Error(g.f('Encountered an error while dereferencing %s. Details: %s ',
      swaggerArtifact.filePath, err.message));
  }
  // It is possible that we expanded name/version from a ref. Set the value from the fully expanded object
  // into the returned artifact
  if (swaggerArtifact.data && swaggerArtifact.data.info) {
    swaggerArtifact.version = swaggerArtifact.data.info.version || swaggerArtifact.version;
    swaggerArtifact.name = swaggerArtifact.data.info['x-ibm-name'] || swaggerArtifact.name;
  }
  return Promise.resolve(swaggerArtifact);
};

var yamlRe = /[.](yaml|yml|json)$/i;
function expandExternalRefs(obj, objFileName, state) {
  // If we don't have any state, obj is a root swagger document that we are expanding into. We don't
  // allow $refs in the root of this object so don't expand
  var rootDoc = !state;
  state = state || { cache: {} };
  objFileName = objFileName.toLowerCase();
  if (state.cache[objFileName]) {
    return obj;
  }
  state.cache[objFileName] = obj;

  var baseDir = path.dirname(objFileName);
  // Walk through entire object and look for $ref to a .yaml file
  return traverse(obj).forEach(function(node) {
    if (node && node['$ref'] && yamlRe.test(node['$ref'])) {
      // Only expand $refs if we're not processing the root node of a root document
      if (rootDoc === true && this.isRoot) {
        return;
      }
      // Don't expand $refs that refer to locally referenced artifacts
      if (node['$ref'].startsWith('#')) {
        return;
      }
      var refPath = path.resolve(baseDir, node['$ref']).toLowerCase();
      if (state.cache[refPath]) {
        this.update(state.cache[refPath], true);
      } else {
        var refdObj = jsYaml.safeLoad(fs.readFileSync(refPath));
        var expandedObj = expandExternalRefs(refdObj, refPath, state);
        // Try to expand the file we just loaded
        this.update(expandedObj, true);
      }
    }
  });
}

module.exports = derefArtifacts;

